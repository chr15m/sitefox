(ns sitefox.auth
  (:require
    [cljs.test :refer-macros [is async]]
    [promesa.core :as p]
    ["crypto" :refer [createHash createHmac randomBytes pbkdf2Sync scryptSync randomFillSync createCipheriv createDecipheriv]]
    [sitefox.util :refer [env]]))

(defn make-hmac-token
  "Create an HMAC token to be used for verifying data was generated by the server and is unmodified."
  [secret size & materials]
  (let [s (-> (createHash "sha512") (.update secret) .digest)
        h (createHmac "sha512" s)]
    (doseq [v materials]
      (.update h (str v)))
    (-> h
        (.digest "hex")
        (.slice 0 size))))

(defn hash-password
  "Hash a password for storage in a database.
  If `salt` (hex string) is not supplied it will be generated (it should be passed when comparing but not when generating)."
  {:test (fn []
           (let [[e s] (hash-password "goober")
                 [e2 s2] (hash-password "goober" s)
                 [e3] (hash-password "something" s)
                 [e4] (hash-password "goober")
                 [e5] (hash-password "goober" "deadc0de")]
             (is (= e e2))
             (is (= s s2))
             (is (not= e e3))
             (is (not= e e4))
             (is (not= e e5))))}
  [pw & [salt]]
  (let [salt (if salt
               (js/Buffer.from salt "hex")
               (randomBytes 16))]
    [(.toString (pbkdf2Sync pw salt 310000 32 "sha512") "hex")
     (.toString salt "hex")]))

(defn encrypt-for-transit
  "Encrypts a piece of data for transit using symmetric key cryptography and the server's own secret."
  [materials]
  (js/Promise.
    (fn [res _err]
      (let [secret (env "SECRET" "DEVMODE")
            k (scryptSync secret "encrypt-for-transit" 24)
            iv (randomFillSync (js/Uint8Array. 16))
            encoded (-> materials clj->js js/JSON.stringify)]
        (when (= secret "DEVMODE") (js/console.error "Warning: env var SECRET is not set."))
        (let [cipher (createCipheriv "aes-192-cbc" k iv)
              assembled (str
                          (-> iv js/Buffer.from (.toString "hex"))
                          (.update cipher encoded "utf8" "hex")
                          (.final cipher "hex"))]
          (res assembled))))))

(defn decrypt-for-transit
  "Decrypts a piece of data using symmetric key cryptography and the server's own secret."
  {:test (fn []
           (async done
                  (p/catch
                    (p/let [vi "some string of data"
                            vx (encrypt-for-transit vi)
                            vo (decrypt-for-transit vx)
                            vi2 (clj->js {:something 42 :h [1 2 4]})
                            vx2 (encrypt-for-transit vi2)
                            vo2 (decrypt-for-transit vx2)]
                      (is (= vi vo))
                      (is (= (js->clj vi2) (js->clj vo2)))
                      ; test failing decrypt
                      (decrypt-for-transit (.slice vo2 1)))
                    (fn []
                      (done)))))}
  [encrypted]
  (js/Promise.
    (fn [res _err]
      (let [secret (env "SECRET" "DEVMODE")
            k (scryptSync secret "encrypt-for-transit" 24)
            iv-src (.slice encrypted 0 32)
            msg (.slice encrypted 32)
            iv (js/Buffer.from iv-src "hex")
            cipher (createDecipheriv "aes-192-cbc" k iv)
            raw (str
                  (.update cipher msg "hex" "utf8")
                  (.final cipher "utf8"))
            decoded (-> raw js/JSON.parse)]
        (res decoded)))))

(defn timestamp-expired?
  "Check if a timestamp (ms) has expired."
  {:test (fn []
           (let [now (-> (js/Date.) (.getTime))]
             (is (timestamp-expired? nil 1))
             (is (timestamp-expired? "BLAH" 1))
             (is (timestamp-expired? (- now 3000) 2000))
             (is (timestamp-expired? now -1))
             (is (not (timestamp-expired? now 500)))
             (is (not (timestamp-expired? now 2000)))
             (is (not (timestamp-expired? (- now 1500) 2000)))
             (is (not (timestamp-expired? (+ now 1000) 2000)))))}
  [time-stamp milliseconds]
  (let [time-stamp (js/parseInt time-stamp)]
    (or
      (js/isNaN time-stamp)
      (< time-stamp (-> (js/Date.) (.getTime) (- milliseconds))))))
